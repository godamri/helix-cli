package repository

import (
	"context"
	{{- if eq .Driver "pgx" }}
	"database/sql"
	"strings"
	"time"
	"fmt"
	{{- end }}
	"log/slog"
	
	"github.com/google/uuid"
	dto "{{ .GoModuleName }}/internal/core/dto/v1"
	"{{ .GoModuleName }}/internal/core/entity"
	"{{ .GoModuleName }}/internal/core/port"
	{{- if eq .Driver "ent" }}
	"{{ .GoModuleName }}/ent"
	"{{ .GoModuleName }}/ent/{{ .EntityNameLower }}"
	{{- end }}
)

{{- if eq .Driver "ent" }}
// =============================================================================
// ENT IMPLEMENTATION (ORM)
// =============================================================================

type {{ .EntityName }}Repository struct {
	client *ent.Client
	logger *slog.Logger
}

func New{{ .EntityName }}Repository(client *ent.Client) port.{{ .EntityName }}Repository {
	return &{{ .EntityName }}Repository{
		client: client,
		logger: slog.Default().With("repository", "{{ .EntityName }}"),
	}
}

// connEnt extracts the transactional client if present
func (r *{{ .EntityName }}Repository) connEnt(ctx context.Context) *ent.Client {
	if tx, ok := ctx.Value(txKey{}).(*ent.Tx); ok {
		return tx.Client()
	}
	return r.client
}

func (r *{{ .EntityName }}Repository) Create(ctx context.Context, e *entity.{{ .EntityName }}) error {
	_, err := r.connEnt(ctx).{{ .EntityName }}.Create().
		SetID(e.ID).
		SetName(e.Name).
		SetIsActive(e.IsActive).
		SetCreatedAt(e.CreatedAt).
		SetUpdatedAt(e.UpdatedAt).
		Save(ctx)
	if err != nil {
		if ent.IsConstraintError(err) {
			return entity.WrapError(entity.ECONFLICT, "duplicate_entry", err)
		}
		return err
	}
	return nil
}

func (r *{{ .EntityName }}Repository) FindByID(ctx context.Context, id uuid.UUID) (*entity.{{ .EntityName }}, error) {
	res, err := r.connEnt(ctx).{{ .EntityName }}.Get(ctx, id)
	if err != nil {
		if ent.IsNotFound(err) {
			return nil, nil
		}
		return nil, err
	}
	return &entity.{{ .EntityName }}{
		ID:        res.ID,
		Name:      res.Name,
		IsActive:  res.IsActive,
		CreatedAt: res.CreatedAt,
		UpdatedAt: res.UpdatedAt,
	}, nil
}

func (r *{{ .EntityName }}Repository) Update(ctx context.Context, e *entity.{{ .EntityName }}) error {
	return r.connEnt(ctx).{{ .EntityName }}.UpdateOneID(e.ID).
		SetName(e.Name).
		SetIsActive(e.IsActive).
		SetUpdatedAt(e.UpdatedAt).
		Exec(ctx)
}

func (r *{{ .EntityName }}Repository) Delete(ctx context.Context, id uuid.UUID) error {
	// Ent throws specific error if ID not found. We must swallow it to behave like SQL DELETE.
	// If it's gone, it's gone. That's a success.
	err := r.connEnt(ctx).{{ .EntityName }}.DeleteOneID(id).Exec(ctx)
	if err != nil && !ent.IsNotFound(err) {
		return err
	}
	return nil
}

func (r *{{ .EntityName }}Repository) List(ctx context.Context, req dto.List{{ .EntityName }}Request) ([]*entity.{{ .EntityName }}, int, error) {
	q := r.connEnt(ctx).{{ .EntityName }}.Query()

	if req.Search != "" {
		q.Where({{ .EntityNameLower }}.NameContainsFold(req.Search))
	}
	if req.IsActive != nil {
		q.Where({{ .EntityNameLower }}.IsActiveEQ(*req.IsActive))
	}

	total, err := q.Count(ctx)
	if err != nil {
		return nil, 0, err
	}

	q.Limit(req.PageSize).Offset((req.Page - 1) * req.PageSize)
	
	// Default Sort
	q.Order(ent.Desc({{ .EntityNameLower }}.FieldCreatedAt))

	res, err := q.All(ctx)
	if err != nil {
		return nil, 0, err
	}

	items := make([]*entity.{{ .EntityName }}, len(res))
	for i, v := range res {
		items[i] = &entity.{{ .EntityName }}{
			ID: v.ID, Name: v.Name, IsActive: v.IsActive, CreatedAt: v.CreatedAt, UpdatedAt: v.UpdatedAt,
		}
	}
	return items, total, nil
}

// Bulk Ops for Ent
func (r *{{ .EntityName }}Repository) BulkCreate(ctx context.Context, entities []*entity.{{ .EntityName }}) error {
	builders := make([]*ent.{{ .EntityName }}Create, len(entities))
	for i, e := range entities {
		builders[i] = r.connEnt(ctx).{{ .EntityName }}.Create().
			SetID(e.ID).SetName(e.Name).SetIsActive(e.IsActive).SetCreatedAt(e.CreatedAt).SetUpdatedAt(e.UpdatedAt)
	}
	return r.connEnt(ctx).{{ .EntityName }}.CreateBulk(builders...).Exec(ctx)
}

func (r *{{ .EntityName }}Repository) BulkUpdateStatus(ctx context.Context, ids []uuid.UUID, isActive bool) (int, error) {
	n, err := r.connEnt(ctx).{{ .EntityName }}.Update().Where({{ .EntityNameLower }}.IDIn(ids...)).SetIsActive(isActive).Save(ctx)
	return n, err
}

func (r *{{ .EntityName }}Repository) BulkDelete(ctx context.Context, ids []uuid.UUID) error {
	_, err := r.connEnt(ctx).{{ .EntityName }}.Delete().Where({{ .EntityNameLower }}.IDIn(ids...)).Exec(ctx)
	return err
}

func (r *{{ .EntityName }}Repository) Exists(ctx context.Context, id uuid.UUID) (bool, error) {
	return r.connEnt(ctx).{{ .EntityName }}.Query().Where({{ .EntityNameLower }}.IDEQ(id)).Exist(ctx)
}

func (r *{{ .EntityName }}Repository) Count(ctx context.Context, req dto.List{{ .EntityName }}Request) (int, error) {
	q := r.connEnt(ctx).{{ .EntityName }}.Query()
	return q.Count(ctx)
}

func (r *{{ .EntityName }}Repository) ListWithCursor(ctx context.Context, req dto.CursorPaginationRequest) ([]*entity.{{ .EntityName }}, string, bool, error) {
	// Not implemented for Ent template brevity, fallback to offset
	return nil, "", false, nil
}

{{- else }}
// =============================================================================
// PGX / RAW SQL IMPLEMENTATION
// =============================================================================

type {{ .EntityName }}Repository struct {
	db     *sql.DB
	logger *slog.Logger
}

func New{{ .EntityName }}Repository(db *sql.DB) port.{{ .EntityName }}Repository {
	return &{{ .EntityName }}Repository{
		db:     db,
		logger: slog.Default().With("repository", "{{ .EntityName }}"),
	}
}

func (r *{{ .EntityName }}Repository) conn(ctx context.Context) port.SQLQuerier {
	return GetConn(ctx, r.db)
}

func (r *{{ .EntityName }}Repository) Create(ctx context.Context, e *entity.{{ .EntityName }}) error {
	query := `INSERT INTO {{ .EntityPluralLower }} (id, name, is_active, created_at, updated_at) 
	          VALUES ($1, $2, $3, $4, $5)`
	_, err := r.conn(ctx).ExecContext(ctx, query, e.ID, e.Name, e.IsActive, e.CreatedAt, e.UpdatedAt)
	if err != nil {
		if strings.Contains(err.Error(), "unique_violation") {
			return entity.WrapError(entity.ECONFLICT, "duplicate_entry", err)
		}
		return err
	}
	return nil
}

func (r *{{ .EntityName }}Repository) FindByID(ctx context.Context, id uuid.UUID) (*entity.{{ .EntityName }}, error) {
	query := `SELECT id, name, is_active, created_at, updated_at FROM {{ .EntityPluralLower }} WHERE id = $1`
	var e entity.{{ .EntityName }}
	err := r.conn(ctx).QueryRowContext(ctx, query, id).Scan(&e.ID, &e.Name, &e.IsActive, &e.CreatedAt, &e.UpdatedAt)
	if err != nil {
		if err == sql.ErrNoRows {
			return nil, nil
		}
		return nil, err
	}
	return &e, nil
}

func (r *{{ .EntityName }}Repository) Update(ctx context.Context, e *entity.{{ .EntityName }}) error {
	query := `UPDATE {{ .EntityPluralLower }} SET name = $1, is_active = $2, updated_at = $3 WHERE id = $4`
	res, err := r.conn(ctx).ExecContext(ctx, query, e.Name, e.IsActive, e.UpdatedAt, e.ID)
	if err != nil {
		return err
	}
	rows, _ := res.RowsAffected()
	if rows == 0 {
		return entity.ErrNotFound
	}
	return nil
}

func (r *{{ .EntityName }}Repository) Delete(ctx context.Context, id uuid.UUID) error {
	query := `DELETE FROM {{ .EntityPluralLower }} WHERE id = $1`
	_, err := r.conn(ctx).ExecContext(ctx, query, id)
	return err
}

func (r *{{ .EntityName }}Repository) List(ctx context.Context, req dto.List{{ .EntityName }}Request) ([]*entity.{{ .EntityName }}, int, error) {
	where, args := r.applyFilters(req.IsActive, req.IDs, req.Search)
	
	countQuery := fmt.Sprintf("SELECT COUNT(*) FROM {{ .EntityPluralLower }} %s", where)
	var total int
	if err := r.conn(ctx).QueryRowContext(ctx, countQuery, args...).Scan(&total); err != nil {
		return nil, 0, err
	}

	sortCol := "created_at"
	if req.SortBy == "name" { sortCol = "name" }
	order := "DESC"
	if strings.ToLower(req.SortOrder) == "asc" { order = "ASC" }

	limit := req.PageSize
	offset := (req.Page - 1) * req.PageSize
	
	finalArgs := append(args, limit, offset)
	query := fmt.Sprintf(
		"SELECT id, name, is_active, created_at, updated_at FROM {{ .EntityPluralLower }} %s ORDER BY %s %s LIMIT $%d OFFSET $%d",
		where, sortCol, order, len(args)+1, len(args)+2,
	)

	rows, err := r.conn(ctx).QueryContext(ctx, query, finalArgs...)
	if err != nil {
		return nil, 0, err
	}
	defer rows.Close()

	items := []*entity.{{ .EntityName }}{}
	for rows.Next() {
		var e entity.{{ .EntityName }}
		if err := rows.Scan(&e.ID, &e.Name, &e.IsActive, &e.CreatedAt, &e.UpdatedAt); err != nil {
			return nil, 0, err
		}
		items = append(items, &e)
	}

	return items, total, nil
}

// Bulk Helpers for SQL
func (r *{{ .EntityName }}Repository) BulkCreate(ctx context.Context, entities []*entity.{{ .EntityName }}) error {
	if len(entities) == 0 { return nil }
	// Simplistic bulk insert loop for template. Production should use CopyFrom or multi-value insert builder.
	// For template simplicity we use a loop here, but user should optimize if >1000 rows.
	for _, e := range entities {
		if err := r.Create(ctx, e); err != nil { return err }
	}
	return nil
}

func (r *{{ .EntityName }}Repository) BulkUpdateStatus(ctx context.Context, ids []uuid.UUID, isActive bool) (int, error) {
	if len(ids) == 0 { return 0, nil }
	query := `UPDATE {{ .EntityPluralLower }} SET is_active = $1, updated_at = $2 WHERE id = ANY($3)`
	res, err := r.conn(ctx).ExecContext(ctx, query, isActive, time.Now(), ids)
	if err != nil { return 0, err }
	n, _ := res.RowsAffected()
	return int(n), nil
}

func (r *{{ .EntityName }}Repository) BulkDelete(ctx context.Context, ids []uuid.UUID) error {
	if len(ids) == 0 { return nil }
	query := `DELETE FROM {{ .EntityPluralLower }} WHERE id = ANY($1)`
	_, err := r.conn(ctx).ExecContext(ctx, query, ids)
	return err
}

func (r *{{ .EntityName }}Repository) Exists(ctx context.Context, id uuid.UUID) (bool, error) {
	var exists bool
	query := `SELECT EXISTS(SELECT 1 FROM {{ .EntityPluralLower }} WHERE id = $1)`
	err := r.conn(ctx).QueryRowContext(ctx, query, id).Scan(&exists)
	return exists, err
}

func (r *{{ .EntityName }}Repository) Count(ctx context.Context, req dto.List{{ .EntityName }}Request) (int, error) {
	where, args := r.applyFilters(req.IsActive, req.IDs, req.Search)
	query := fmt.Sprintf("SELECT COUNT(*) FROM {{ .EntityPluralLower }} %s", where)
	var count int
	err := r.conn(ctx).QueryRowContext(ctx, query, args...).Scan(&count)
	return count, err
}

func (r *{{ .EntityName }}Repository) ListWithCursor(ctx context.Context, req dto.CursorPaginationRequest) ([]*entity.{{ .EntityName }}, string, bool, error) {
	return nil, "", false, nil
}

func (r *{{ .EntityName }}Repository) applyFilters(isActive *bool, ids []string, search string) (string, []interface{}) {
	var filters []string
	var args []interface{}
	argId := 1

	if isActive != nil {
		filters = append(filters, fmt.Sprintf("is_active = $%d", argId))
		args = append(args, *isActive)
		argId++
	}
	if search != "" {
		filters = append(filters, fmt.Sprintf("name ILIKE $%d", argId))
		args = append(args, "%"+search+"%")
		argId++
	}
	
	where := ""
	if len(filters) > 0 {
		where = "WHERE " + strings.Join(filters, " AND ")
	}
	return where, args
}
{{- end }}